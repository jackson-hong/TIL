# 5/7 System Design

Date: May 7, 2022 11:00 PM

### 누출 버킷 알고리즘

- 토큰 버킷과 비슷하지만 요청 처리율이 고정되어있음
- 보통 FIFO 큐로 구현
- 동작 원리
    - 요청이 도착시 큐가 가득차 있는지 확인 후 빈자리가 있는 경우 큐에 요청을 추가
    - 가득 차 있는 경우 요청은 버려짐
    - 지정된 시간마다 큐에서 요청을 꺼내어 처리한다.
- 버킷크기, 처리율 이렇게 두가지를 인자로 받는다.
- 장점
    - 큐의 크기가 고정되어 메모리 사용 측면에서 효율적
    - 고정된 처리율 → 안정적 출력
- 단점
    - 단시간 많은 트래픽이 몰리는 경우 최신 요청들이 버려짐
    - 두 개 인자를 갖고 있는 경우, 이들을 올바르게 튜닝하기 까다로울 수 있다.

### 고정 윈도 카운터 알고리즘

- 동작원리
    - 타임라인을 고정된 간격(window)로 나누고, 각 윈도 마다 카운터를 붙인다
    - 요청 접수시 카운터 1 증가
    - 카운터 임계치 도달시 새로운 요청은 새 윈도가 열릴 때까지 버려짐
- 장점
    - 메모리 효율
    - 이해하기 쉬움
    - 윈도가 닫히는 시점에 초기화하는 방식은 특정 트래픽 패턴을 처리하기 적합함
- 단점
    - 윈도 경계 부근에 많은 트래픽이 몰려드는 경우 한도보다 많은 양의 요청을 처리하게 된다.

### 이동 윈도 로깅 알고리즘

- 고정 윈도 카운터 알고리즘의 단점을 해결하는 알고리즘
- 동작 원리
    - 요청의 timestamp를 추척하여 캐시에 보관한다.
    - 새 요청이 오면 만료된 타임 스탬프는 제거한다.
    - 새 요청의 타임스탬프를 로그에 추가
    - 로그의 크기가 허용치보다 같거나 작으면 시스템에 전달. 아닌 경우 처리를 거부
- 장점
    - 메커니즘이 정교하고 허용되는 요청의 개수는 한도를 넘지 않는다.
- 단점
    - 다량의 메모리를 사용하는데, 거부된 요청의 타임스탬프도 보관하기 때문

### 이동 윈도 카운터 알고리즘

- 고정 윈도 카운터 알고리즘과 이동 윈도 로킹 알고리즘을 결합한 것
- 동작 원리
    - 현재 1분간 요청수 + 직전 1분간 요청 수 * 이동 윈도와 직전 1분이 겹치는 비율이 한도보다 낮은 경우 요청을 통과시킨다.
- 장점
    - 이전 시간대에 평균 처리율에 따라 현재 윈도 상태를 계산하므로 짧은 시간에 몰리는 트래픽에도 잘 대응한다.
    - 메모리 효율이 좋다.
- 단점
    - 균등하게 분포되어 있다 가정한 상태에서 추정치를 계산하기 때문에 다소 느슨하다. 그러다 심각한 문제는 아니다.

### 개략적인 아키텍처

- 기본 아이디어는 얼마나 많은 요청이 접수되었는지 카운터를 추적 대상 별로 두고 이 카운터 값이 어떤 한도를 넘어서면 한도를 넘어 도착한 요청은 거부하는 것
- 이 카운터는 빠른 반응속도가 중요하기 때문에 메모리상에 도착하는 캐시가 바람직하다 → 레디스
- 개괄적 동작 원리
    1. 클라이언트가 처리율 제한 미들웨어에 요청을 보냄
    2. 처리율 제한 미들웨어는 레디스의 지정 버킷에서 카운터를 가져와 한도에 도달했는지 검사
    3. 도달하지 않았다면 API 서버로 전달