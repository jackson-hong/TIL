# 12/27 코틀린 복습

** Long 타입의 경우 크기가 너무 큰 경우 자동으로 L을 붙임

var : 선언 후 변경 가능

val : 선언 후 변경 불가능

```kotlin
var/val 변수명 : 타입 = 값
```

** 타입 뒤에 ? 의 유무에 따라 null을 허용하거나 허용하지 않는다

** parameter에 기본값을 지정해줄 수 있다

```kotlin
fun test(a1:Int = 0, a2:Double = 0.0){
	...
}
```

** Unit = void(java) 동일하다 → 반환값이 없다 → 생략가능

** 지역함수 = 함수 내에서 선언한 함수로 상위함수 내에서만 사용 가능하다

When = switch(java)

```kotlin
when(a1){
	1 -> fun1()
	2 -> fun2()
	else -> fun3()
}
```

** 연속된 값의 배열은 ...으로 표현이 가능하다

### 함수형 프로그래밍

- 코틀린은 함수형 프로그래밍을 지향하고 함수형 프로그래밍을 위한 다양한 기능들을 지원한다.

```kotlin
fun test1(a1:Int, a2:Int) : Int {
	return a1 + a2
}
// 동일한 코드이다
fun test2(a1:Int, a2:Int) : Int = a1 + a2
```

- 람다식을 통해 특정 함수 내에서만 사용하는 연산코드 사용시 활용할 수 있다

** 코틀린은 기본적으로 추론이 가능하면 생략이 가능하다

** 람다식에서 마지막 줄은 return으로 간주한다

```kotlin
val lamb1 = (Int,Int) -> Int = {a1:Int, a2:Int -> a1 + a2}

val r4 = lamb1(100,200) // 300

val lamb2 = {a1:Int, a2:Int -> a1 + a2}

val r5 = lamb2(300,400) // 700
```

- 인라인 함수 : Kotlin 코드가 Java 코드로 변경될 때 함수를 호출하는 코드를 함수내에 구현한 코드로 변경하는 함수
    - 함수 호출 방식은 전체 코드양이 줄어들어 메모리를 적게 쓰나는 장점이 있지만 호출 시 코드 흐름이 이동하고 다시 돌아와야 하기 때문에 작업량이 늘어난다
    - 인라인 함수는 전체 코드양이 늘어 메모리를 더 많이 사용하지만 코드 흐름의 이동 없이 수행되기 때문에 작업량이 늘어나지 않는다 - 성능이 더 좋다
- 확장 함수 : 기존 클래스에 새로운 함수를 추가하는 개념
    - Kotlin 코드에서는 기존 클래스에 메소드를 추가해 사용하는 것처럼 보이지만 사실 객체의 주소 값을 받은 함수가 만들어지고 그 함수를 호출하는 방식으로 동작한다
- 고차 함수 : 함수를 매개변수로 받거나 반환 타입이 함수인 함수를 고차 함수라고 부른다.
    - 함수 호출시 전달하는 함수와 반환 하는 함수는 람다식을 사용할 수 있다